'From Moshi of 3 March 2007 [latest update: #908] on 21 May 2009 at 1:17:33 pm'!
Exception subclass: #OM2Fail
	instanceVariableNames: 'parserFailedAt'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
Object subclass: #OM2Failer
	instanceVariableNames: 'used'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
Object subclass: #OM2Stream
	instanceVariableNames: 'head tail memo'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
OM2Stream subclass: #OM2StreamProxy
	instanceVariableNames: 'target'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
OM2Stream subclass: #OM2StreamDebugger
	instanceVariableNames: 'om2stream'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
OM2Stream subclass: #OM2LazyStream
	instanceVariableNames: 'stream pos'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
OM2Stream subclass: #OM2EndOfStream
	instanceVariableNames: 'stream pos'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
Compiler subclass: #OMeta2Compiler
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
Object subclass: #OMeta2Base
	instanceVariableNames: 'input om2streams haltingPoint'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2Preload'!
OMeta2Base subclass: #OMeta2
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!
OMeta2 subclass: #OMeta2RuleParser
	instanceVariableNames: 'temps'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!
OMeta2 subclass: #OMeta2RuleTranslator
	instanceVariableNames: 'grammarClass'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!
OMeta2 subclass: #OMeta2Optimizer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!
OMeta2 subclass: #OMeta2Flattener
	instanceVariableNames: 'ws'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!

!OM2Fail commentStamp: '<historical>' prior: 0!
I represent a match failure.  Try using #matchAll:with:ifFail: rather than handling me directly.!

!OM2Failer commentStamp: '<historical>' prior: 0!
I am used to capture left recursion failures.  Do not use me directly, I am an implementation detail.!

!OM2Stream commentStamp: '<historical>' prior: 0!
I, and my subclasses, are specialized pseudo-streams used by OMeta parsers.  We are implementation details... do not instantiate us.!

!OMeta2Compiler commentStamp: '<historical>' prior: 0!
I provide the interface that the Smalltalk environment expects.  In turn, I call out to various OMeta parsers that actually perform the compilation.

I use the indirection provided by OMeta2 class methods to allow for overriding of various functionality and make things a bit easier when trying out new extensions and optimization ideas for OMeta.! 

!OMeta2Base commentStamp: '<historical>' prior: 0!
I provide the core language/library runtime support for OMeta that cannot be rewritten as OMeta code.!

!OMeta2 commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2RuleParser commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2RuleTranslator commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2Optimizer commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2Flattener commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

MethodNode subclass: #OMeta2MethodNode
        instanceVariableNames: ''
        classVariableNames: ''
        poolDictionaries: ''
        category: 'OMeta2Preload'!

!OMeta2MethodNode commentStamp: '<historical>' prior: 0!
I exist so that OMeta methods can be viewed in the code browsers.!

!OMeta2MethodNode methodsFor: 'debugger support' stamp: 'hmm 8/25/2012 14:28'!
schematicTempNamesString
        "The decompiler wants a list of temp names. However, this mechanism depends on a number of assumptions that do not hold with OMeta2 generated methods. Therefore we simply skip the temp names, letting the decompiler build generic ones.

This fixes an error when attempting to prettyPrint OMeta source code. (prettyPrint reveals the actual Smalltalk code generated by OMeta)"
        ^nil! !

!OMeta2 class methodsFor: 'methods' stamp: 'jmv 5/23/2019 10:44:30'!
methodNodeFor: sourceCode noPattern: aBoolean
	(OMeta2RuleParser isOMeta2Rule: sourceCode) ifTrue: [ ^ nil ].
	^ super methodNodeFor: sourceCode noPattern: aBoolean! !

!OM2Fail class methodsFor: 'exceptionInstantiator' stamp: 'pb 9/5/2017 13:01'!
parserFailedAt: positionInStream
	^ self new
		privateParserFailedAt: positionInStream;
		signal.! !

!OM2Fail methodsFor: 'exceptionDescription' stamp: 'aw 2/26/2009 11:03'!
defaultAction

	self error: 'match failed'! !

!OM2Fail methodsFor: 'accessing' stamp: 'pb 9/5/2017 13:01'!
parserFailedAt
	^ parserFailedAt.! !

!OM2Fail methodsFor: 'private' stamp: 'pb 9/5/2017 13:01'!
privateParserFailedAt: pos
	parserFailedAt := pos.! !

!OM2Failer methodsFor: 'initialization' stamp: 'aw 2/16/2009 14:23'!
initialize

	used := false! !

!OM2Failer methodsFor: 'initialization' stamp: 'aw 2/27/2009 13:44'!
used

	^ used! !

!OM2Failer methodsFor: 'evaluating' stamp: 'aw 2/27/2009 13:42'!
value

	used := true.
	OM2Fail signal! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 11:04'!
basicTail

	^ tail! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'pb 4/25/2020 01:00'!
ometaForgetEverything

	memo := IdentityDictionary new! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/16/2009 11:35'!
head

	^ head! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/16/2009 13:38'!
initHead: h tail: t

	head := h.
	tail := t! !

!OM2Stream methodsFor: 'initialization' stamp: 'aw 2/16/2009 11:34'!
initialize

	memo := IdentityDictionary new! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:13'!
inputSpecies

	^ Array! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/16/2009 14:13'!
memo

	^ memo! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'pb 4/25/2020 01:00'!
ometaPositionInStream

	^ -1! !

!OM2Stream methodsFor: 'printing' stamp: 'aw 2/26/2009 11:05'!
printOn: aStream

	| inputIsString curr |
	inputIsString := (self inputSpecies inheritsFrom: String) and: [(self inputSpecies inheritsFrom: Symbol) not].
	curr := self.
	aStream
		nextPutAll: 'an ';
		nextPutAll: self class name;
		nextPut: $(.
	[curr notNil] whileTrue: [
		(curr isKindOf: OM2EndOfStream) ifTrue: [
			aStream nextPut: $).
			^ self
		].
		inputIsString
			ifTrue: [aStream nextPut: curr head]
			ifFalse: [
				curr head printOn: aStream.
				aStream space
			].
		curr := curr basicTail.
	].
	aStream nextPutAll: '...)'! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/16/2009 11:35'!
tail

	^ tail! !

!OM2Stream methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 11:40'!
transitiveForgetEverything

	| curr |
	curr := self.
	[curr notNil] whileTrue: [
		curr ometaForgetEverything.
		curr := curr basicTail
	]! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 11:05'!
basicTail

	^ target basicTail! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'pb 2/21/2018 2:29'!
head

	^ head ifNil: [head := target head].
! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:45'!
initTarget: anOM2Stream

	target := anOM2Stream! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:13'!
inputSpecies

	^ target inputSpecies! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'pb 4/25/2020 01:00'!
ometaPositionInStream

	^ target ometaPositionInStream! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'pb 2/21/2018 2:29'!
tail

	^ tail ifNil: [tail := OM2StreamProxy for: target tail].
! !

!OM2StreamProxy methodsFor: 'private-ometa2preload' stamp: 'aw 2/16/2009 14:10'!
target

	^ target! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

OM2StreamProxy class
	instanceVariableNames: ''!

!OM2StreamProxy class methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:44'!
for: anOM2Stream

	^ self new initTarget: anOM2Stream! !


!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'pb 4/25/2020 01:00'!
ometaForgetEverything

	om2stream ometaForgetEverything! !

!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 13:40'!
head

	^ om2stream head! !

!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 15:26'!
initOm2stream: anOM2Stream

	om2stream := anOM2Stream! !

!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'aw 2/27/2009 13:27'!
memo

	^ om2stream memo! !

!OM2StreamDebugger methodsFor: 'printing' stamp: 'aw 2/26/2009 15:57'!
printOn: aStream

	aStream nextPutAll: 'an OM2StreamDebugger('.
	om2stream printOn: aStream.
	aStream nextPut: $)! !

!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 13:40'!
tail

	^ om2stream tail! !

!OM2StreamDebugger methodsFor: 'private-ometa2preload' stamp: 'aw 2/27/2009 13:29'!
transitiveForgetEverything

	om2stream transitiveForgetEverything! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

OM2StreamDebugger class
	instanceVariableNames: ''!

!OM2StreamDebugger class methodsFor: 'private-ometa2preload' stamp: 'aw 2/26/2009 15:28'!
for: anOM2Stream

	^ self new initOm2stream: anOM2Stream! !

!OM2LazyStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/20/2009 14:50'!
initHead: h stream: s pos: p

	head := h.
	stream := s.
	pos := p! !

!OM2LazyStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:15'!
inputSpecies

	^ stream originalContents species! !

!OM2LazyStream methodsFor: 'private-ometa2preload' stamp: 'pb 4/25/2020 01:00'!
ometaPositionInStream

	^ pos! !

!OM2LazyStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/20/2009 14:42'!
tail

	tail ifNil: [tail := OM2LazyStream for: stream withPos: pos + 1].
	^ tail! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

OM2LazyStream class
	instanceVariableNames: ''!

!OM2LazyStream class methodsFor: 'private-ometa2preload' stamp: 'aw 2/20/2009 14:44'!
for: aReadStream withPos: pos

	^ aReadStream atEnd
		ifTrue: [OM2EndOfStream new initStream: aReadStream pos: pos]
		ifFalse: [self new initHead: aReadStream next stream: aReadStream pos: pos]! !

!OM2EndOfStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/25/2009 11:29'!
head

	OM2Fail signal! !

!OM2EndOfStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/20/2009 14:50'!
initStream: s pos: p

	stream := s.
	pos := p! !

!OM2EndOfStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/19/2009 23:14'!
inputSpecies

	^ stream originalContents species! !

!OM2EndOfStream methodsFor: 'private-ometa2preload' stamp: 'pb 4/25/2020 01:00'!
ometaPositionInStream

	^ pos! !

!OM2EndOfStream methodsFor: 'private-ometa2preload' stamp: 'aw 2/25/2009 11:29'!
tail

	OM2Fail signal! !


!OMeta2Compiler methodsFor: 'private-ometa2preload' stamp: 'aw 2/18/2009 16:30'!
compile: origCode in: cls classified: aCategory notifying: notify ifFail: failBlock

	^ self compile: origCode in: cls notifying: notify ifFail: failBlock! !

!OMeta2Compiler methodsFor: 'private-ometa2preload' stamp: 'pb 4/27/2020 22:00'!
compile: origCode in: cls notifying: notify ifFail: failBlock

	| origCodeStream parseTree structuredCode translatedCode compilerStage|
	origCodeStream := origCode asString readStream.
	self from: origCodeStream class: cls context: nil notifying: notify.
	[
		compilerStage := 'Parsing'.
		parseTree := cls ometa2RuleParserClass matchStream: origCodeStream with: #rule withArgs: #() withPlaybackDebugging: false.
		compilerStage := 'Optimizing'.
		parseTree := cls ometa2OptimizerClass optimizeOMetaAst: parseTree.
		compilerStage := 'Translating'.
		structuredCode := cls ometa2RuleTranslatorClass match: parseTree with: #translate withArgs: {cls}.
		compilerStage := 'Flattening'.
		translatedCode := cls ometa2FlattenerClass match: structuredCode with: #flatten
	] on: OM2Fail do: [
		self notify: '<-- parse error around here -->' at: origCodeStream position.
		^ failBlock value
	].
	^ Compiler new
		compile: translatedCode readStream
		in: cls
		notifying: notify
		ifFail: failBlock! !

!OMeta2Compiler methodsFor: 'private-ometa2preload' stamp: 'aw 2/27/2009 13:10'!
parserClass

	^ self class! !

!OMeta2Compiler methodsFor: 'private-ometa2preload' stamp: 'pb 4/27/2020 22:00'!
parse: aStream class: aClass noPattern: noPattern context: ctxt notifying: req ifFail: aBlock

	^ [
		| parseTree structuredCode code node compilerStage|
		compilerStage := 'Parsing'.
		parseTree := aClass ometa2RuleParserClass matchAll: aStream contents with: #rule.
		compilerStage := 'Optimizing'.
		parseTree := aClass ometa2OptimizerClass optimizeOMetaAst: parseTree.
		compilerStage := 'Translating'.
		structuredCode := aClass ometa2RuleTranslatorClass match: parseTree with: #translate withArgs: {aClass}.
		compilerStage := 'Flattening'.
		code := aClass ometa2FlattenerClass match: structuredCode with: #flatten.
		node := Parser new parse: code readStream class: aClass noPattern: noPattern context: ctxt notifying: req ifFail: aBlock.
		OMeta2MethodNode adoptInstance: node.
		node
	] on: OM2Fail do: [aBlock value]! !

!OMeta2Compiler methodsFor: 'private-ometa2preload' stamp: 'hmm 5/24/2010 10:51'!
parser
        ^ self parserClass new! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/16/2009 15:13'!
anything

	| ans |
	ans := input head.
	input := input tail.
	^ ans! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'pb 5/5/2020 19:00'!
applyRule
	"Entry point to enable other rules to apply an arbitrary rule parametrically.  Used primarily by higher order rules (i.e. listOf etc.)"
	| aRule |
	aRule := self privateOMetaApply: #anything.
	^ self privateOMetaApply: aRule! !

!OMeta2Base methodsFor: 'external access' stamp: 'pb 5/5/2020 19:00'!
applyRule: aRule
	"Entry point for external (i.e. non-rule) code to apply an arbitrary rule."
	^ self privateOMetaApply: aRule! !

!OMeta2Base methodsFor: 'external access' stamp: 'pb 5/5/2020 19:00'!
applyRule: aRule withArgs: args
	"Entry point for external (i.e. non-rule) code to apply an arbitrary rule with arguments."
	^ self privateOMetaApply: aRule withArgs: args! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 5/5/2020 19:00'!
privateOMetaApply: aRule
	"Apply taking no arguments.  Non-rule code should not send directly as I am an implementation detail and subject to change.

	A memoRec is an association whose key is the answer, and whose value is the next input. Failers pretend to be memoRecs, but throw a fail in response to #value."
	| memo memoRec |
	input == haltingPoint ifTrue: [self halt].
	memo := input memo.
	memoRec := memo at: aRule ifAbsent: [nil].
	memoRec ifNil: [
		| origInput failer ans |
		origInput := input.
		failer := OM2Failer new.
		memo at: aRule put: failer.
		ans := self perform: aRule.
		memoRec := ans -> input.
		memo at: aRule put: memoRec.
		failer used ifTrue: [
			" left recursion detected "
			| sentinel keepGoing |
			sentinel := input.
			keepGoing := true.
			[keepGoing] whileTrue: [
				[
					input := origInput.
					ans := self perform: aRule.
					input == sentinel ifTrue: [OM2Fail parserFailedAt: input ometaPositionInStream].
					memoRec key: ans value: input.
				] on: OM2Fail do: [keepGoing := false]
			]
		]		
	].
	input := memoRec value.
	^ memoRec key! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 5/5/2020 19:00'!
privateOMetaApply: aRule withArgument: arg
	"Apply taking a single argument, arg. Non-rule code should not send directly as I am an implementation detail and subject to change."
	input := OM2Stream new
		initHead: arg
		tail: input.
	^ self perform: aRule.! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 5/5/2020 19:00'!
privateOMetaApply: aRule withArgs: args
	"Apply taking an argument array, args. Non-rule code should not send directly as I am an implementation detail and subject to change."
	args reverseDo: [:a | input := OM2Stream new initHead: a tail: input].
	^ self perform: aRule! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaConsumedBy: aBlock

	| origInput i ws |
	origInput := input.
	aBlock value.
	ws := WriteStream on: origInput inputSpecies new.
	i := origInput.
	[i == input] whileFalse: [
		ws nextPut: i head.
		i := i tail
	].
	^ ws contents! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaForeignParser

	| aGrammar aRule g ans |
	aGrammar := self privateOMetaApply: #anything.
	aRule := self privateOMetaApply: #anything.
	g := aGrammar new initOMetaInputStream: (OM2StreamProxy for: input).
	ans := g privateOMetaApply: aRule.
	input := g ometaInputStream target.
	^ ans! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 5/2/2020 19:00'!
pvtOMetaGetExternalSmalltalkRecognizerClass
	"Use indirection to avoid hard-coding the parser name"
	^ OMeta2CuisSmalltalkRecognizer.! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
ometaForgetEverything

	input transitiveForgetEverything.
	om2streams valuesDo: [:s | s transitiveForgetEverything]! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 5/24/2019 21:00'!
pvtOMetaIsForm: obj
	^ (obj isCollection and: [obj isSequenceable and: [obj isSymbol not]])! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 5/24/2019 21:00'!
pvtOMetaForm: aBlock

	| v origInput |
	v := self privateOMetaApply: #anything.
	self pvtOMetaPred: (self pvtOMetaIsForm: v).
	origInput := input.
	input := om2streams at: v ifAbsentPut: [OM2LazyStream for: v readStream withPos: 1].
	aBlock value.
	self privateOMetaApply: #end.
	input := origInput.
	^ v! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaGenericMany: aBlock into: anOrderedCollection

	[
		| origInput |
		origInput := input.
		[anOrderedCollection addLast: aBlock value] on: OM2Fail do: [
			input := origInput.
			^ anOrderedCollection
		].
		true
	] whileTrue! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
ometaHaltingPoint: anOM2Stream

	haltingPoint := anOM2Stream! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaIndexConsumedBy: aBlock
	"rangeAssoc"
	| from to |
	from := self ometaPositionInStream.
	aBlock value.
	to := self ometaPositionInStream.
	^ from -> to! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
initOMetaInputStream: i

	input := i! !

!OMeta2Base methodsFor: 'initialization' stamp: 'aw 2/26/2009 11:16'!
initialize

	super initialize.
	om2streams := IdentityDictionary new! !

!OMeta2Base methodsFor: 'private' stamp: 'aw 2/16/2009 14:10'!
ometaInputStream

	^ input! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaLookahead: aBlock

	| origInput ans |
	origInput := input.
	ans := aBlock value.
	input := origInput.
	^ ans! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaMany1: aBlock
	"1 or more matches (i.e. +)"
	^ self pvtOMetaGenericMany: aBlock into: (OrderedCollection with: aBlock value)! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaMany: aBlock
	"0 or more matches (i.e. *)"
	^ self pvtOMetaGenericMany: aBlock into: OrderedCollection new! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaNot: aBlock

	| origInput |
	origInput := input.
	[aBlock value] on: OM2Fail do: [
		input := origInput.
		^ true
	].
	OM2Fail parserFailedAt: input ometaPositionInStream! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 5/24/2019 21:00'!
pvtOMetaOr: choices

	| origInput |
	origInput := input.
	choices do: [:choice |
		input := origInput.
		[^ choice value] on: OM2Fail do: []
	].
	OM2Fail parserFailedAt: input ometaPositionInStream! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaOpt: aBlock

	^ self pvtOMetaOr: {
		[aBlock value].
		[nil]
	}! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
ometaPositionInStream
	"FIXME - called by examples.  Replace calls with @<>?"
	^ input ometaPositionInStream! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/25/2020 01:00'!
pvtOMetaPred: aBooleanValue

	" may want to have the compiler inline this automatically, for performance "
	aBooleanValue ifTrue: [^ true].
	OM2Fail parserFailedAt: input ometaPositionInStream! !

!OMeta2Base methodsFor: 'ometa grammar' stamp: 'aw 2/16/2009 16:16'!
seq

	| xs |
	xs := self privateOMetaApply: #anything.
	xs do: [:x |
		" may want to inline #privateOMetaApply:withArgs: below as an
		  optimization, since this rule gets used a lot "
		self privateOMetaApply: #exactly withArgument: x
	].
	^ xs
	! !

!OMeta2Base methodsFor: 'private' stamp: 'aw 2/16/2009 15:03'!
pvtOMetaSuper: superclass apply: aRule withArgs: args

	args reverseDo: [:a | input := OM2Stream new initHead: a tail: input].
	^ self perform: aRule withArguments: #() inSuperclass: superclass! !

!OMeta2Base methodsFor: 'private' stamp: 'pb 4/30/2020 20:00'!
pvtOMetaSuper: superclass apply: aRule withArgument: argument

	input := OM2Stream new initHead: argument tail: input.
	^ self perform: aRule withArguments: #() inSuperclass: superclass! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

OMeta2Base class
	instanceVariableNames: ''!

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/26/2009 12:35'!
debugMatchAll: aSequenceableCollection with: aRule

	^ self debugMatchAll: aSequenceableCollection with: aRule withArgs: #()! !

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/26/2009 12:53'!
debugMatchAll: aSequenceableCollection with: aRule withArgs: args

	^ self matchStream: aSequenceableCollection readStream with: aRule withArgs: args withPlaybackDebugging: true! !

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/26/2009 12:52'!
debugMatch: anObject with: aRule

	^ self debugMatch: anObject with: aRule withArgs: #()! !

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/26/2009 12:58'!
debugMatch: anObject with: aRule withArgs: args

	^ self debugMatchAll: {anObject} readStream with: aRule withArgs: args! !

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/18/2009 15:39'!
matchAll: aSequenceableCollection with: aRule

	^ self matchAll: aSequenceableCollection with: aRule withArgs: #()! !

!OMeta2Base class methodsFor: 'matching' stamp: 'pb 3/14/2016 02:39'!
matchAll: aSequenceableCollection with: aRule withArgs: args
	"Recommended for use with unstructured data (i.e. strings and simple arrays)"
	^ self matchStream: aSequenceableCollection readStream with: aRule withArgs: args withPlaybackDebugging: false! !

!OMeta2Base class methodsFor: 'matching' stamp: 'pb 4/25/2020 01:00'!
matcherOn: aReadStream

	| input matcher |
	input := OM2LazyStream for: aReadStream withPos: 1.
	matcher := self new initOMetaInputStream: input.
	^ matcher! !

!OMeta2Base class methodsFor: 'private-ometa2preload' stamp: 'pb 4/25/2020 01:00'!
pvtMatchOMetaStream: input matcher: matcher with: aRule withArgs: args withPlaybackDebugging: debugging
	| ans |
	[
	matcher
		applyRule: #empty
		withArgs: args.
	ans := matcher applyRule: aRule.
	matcher applyRule: #end ]
		on: OM2Fail
		do: [ :e | | curr prev prevPrev |
			debugging ifFalse: [ e pass ].
			curr := input.
			prev := nil.
			prevPrev := nil.
			[ curr notNil ] whileTrue: [
				prevPrev := prev.
				prev := curr.
				curr := curr basicTail ].
			curr := prevPrev
				ifNil: [ prev ]
				ifNotNil: [ prevPrev ].
			"FIXME - does this add any value?
		self inform: 'will halt each time matcher reaches ', curr printString.
		"
			matcher
				initOMetaInputStream: input;
				ometaForgetEverything.
			curr ifNil: [ self error: 'you''ve found a bug -- please report it' ].
			curr become: (OM2StreamDebugger for: curr copy).
			matcher ometaHaltingPoint: curr.
			matcher
				applyRule: #empty
				withArgs: args.
			ans := matcher applyRule: aRule.
			matcher applyRule: #end ].
	^ ans! !

!OMeta2Base class methodsFor: 'private-ometa2preload' stamp: 'pb 4/25/2020 01:00'!
matchStream: aReadStream with: aRule withArgs: args withPlaybackDebugging: debugging
	| input matcher |
	input := OM2LazyStream
		for: aReadStream
		withPos: 1.
	matcher := self new initOMetaInputStream: input.
	^ self
		pvtMatchOMetaStream: input
		matcher: matcher
		with: aRule
		withArgs: args
		withPlaybackDebugging: debugging! !

!OMeta2Base class methodsFor: 'matching' stamp: 'pb 3/14/2016 02:39'!
match: anObject with: aRule
	"Recommended for use with structured data (i.e. arrays of arrays etc)"

	^ self match: anObject with: aRule withArgs: #()! !

!OMeta2Base class methodsFor: 'matching' stamp: 'aw 2/26/2009 12:55'!
match: anObject with: aRule withArgs: args

	^ self matchAll: {anObject} readStream with: aRule withArgs: args! !





























OMeta2 subclass: #OMeta2SqueakSmalltalkRecognizer
	instanceVariableNames: 'useArgTypeTable'
	classVariableNames: 'ArgTypeTable TypeTable'
	poolDictionaries: ''
	category: 'OMeta2'!
OMeta2SqueakSmalltalkRecognizer subclass: #OMeta2CuisSmalltalkRecognizer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!
OMeta2 subclass: #OMeta2NullOptimizer
	instanceVariableNames: 'didSomething'
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!
OMeta2NullOptimizer subclass: #OMeta2AndOrOptimizer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!
OMeta2NullOptimizer subclass: #OMeta2FinalizeOptimizer
	instanceVariableNames: ''
	classVariableNames: ''
	poolDictionaries: ''
	category: 'OMeta2'!

!OMeta2SqueakSmalltalkRecognizer commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2CuisSmalltalkRecognizer commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2NullOptimizer commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2AndOrOptimizer commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2FinalizeOptimizer commentStamp: '<historical>' prior: 0!
Smalltalk implementation!

!OMeta2 methodsFor: 'private-ometa2preload'!
char
	| t1 |
	t1 := self privateOMetaApply: #anything.
	self pvtOMetaPred: (t1 isKindOf: Character).
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
digit
	| t1 |
	t1 := self privateOMetaApply: #char.
	self pvtOMetaPred: t1 isDigit.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
empty
	^ true! !

!OMeta2 methodsFor: 'private-ometa2preload'!
end
	^ self
		pvtOMetaNot: [self privateOMetaApply: #anything]! !

!OMeta2 methodsFor: 'private-ometa2preload'!
exactly
	| t1 t2 |
	t1 := self privateOMetaApply: #anything.
	t2 := self privateOMetaApply: #anything.
	self pvtOMetaPred: t1 = t2.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
firstAndRest
	| t1 t2 |
	t1 := self privateOMetaApply: #anything.
	t2 := self privateOMetaApply: #anything.
	^ self
		pvtOMetaGenericMany: [self privateOMetaApply: t2]
		into: (OrderedCollection
				with: (self privateOMetaApply: t1))! !

!OMeta2 methodsFor: 'private-ometa2preload'!
fromTo
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| t x y |
	^ true ifTrue: [
		x := self privateOMetaApply: #anything.
		y := self privateOMetaApply: #anything.
		self
			privateOMetaApply: #seq
			withArgument: x.
		t := self pvtOMetaMany: [
			self pvtOMetaNot: [
				self
					privateOMetaApply: #seq
					withArgument: y ].
			self privateOMetaApply: #anything ].
		self
			privateOMetaApply: #seq
			withArgument: y.
		t ]! !

!OMeta2 methodsFor: 'private-ometa2preload'!
fromToEndOfLine
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| from to |
	^ true ifTrue: [
		from := self privateOMetaApply: #anything.
		to := Character newLineCharacter asString.
		self
			privateOMetaApply: #fromToOrEnd
			withArgs:
				{from. to} ]! !

!OMeta2 methodsFor: 'private-ometa2preload'!
fromToOrEnd
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| t x y |
	^ true ifTrue: [
		x _ self privateOMetaApply: #anything.
		y _ self privateOMetaApply: #anything.
		self
			privateOMetaApply: #seq
			withArgument: x.
		t _ self pvtOMetaMany: [
			self pvtOMetaNot: [
				self
					privateOMetaApply: #seq
					withArgument: y ].
			self privateOMetaApply: #anything ].
		self pvtOMetaOr:
			{
				[
				self
					privateOMetaApply: #seq
					withArgument: y ]. 
				[ self privateOMetaApply: #end ]
			}.
		t ]! !

!OMeta2 methodsFor: 'private-ometa2preload'!
letter
	| t1 |
	t1 := self privateOMetaApply: #char.
	self pvtOMetaPred: t1 isLetter.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
letterOrDigit
	| t1 |
	t1 := self privateOMetaApply: #char.
	self pvtOMetaPred: t1 isAlphaNumeric.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
listOf
	| t1 t2 t3 |
	t1 := self privateOMetaApply: #anything.
	t2 := self privateOMetaApply: #anything.
	^ self pvtOMetaOr: {[t3 := self privateOMetaApply: t1.
		self
			pvtOMetaGenericMany: [self privateOMetaApply: #token withArgument: t2.
				self privateOMetaApply: t1]
			into: (OrderedCollection with: t3)]. [#()]}! !

!OMeta2 methodsFor: 'private-ometa2preload'!
lower
	| t1 |
	t1 := self privateOMetaApply: #char.
	self pvtOMetaPred: t1 isLowercase.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
notLast
	| t1 t2 |
	t1 := self privateOMetaApply: #anything.
	t2 := self privateOMetaApply: t1.
	self
		pvtOMetaLookahead: [self privateOMetaApply: t1].
	^ t2! !

!OMeta2 methodsFor: 'private-ometa2preload'!
number
	| t1 |
	t1 := self privateOMetaApply: #anything.
	self pvtOMetaPred: t1 isNumber.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
range
	| t1 t2 t3 |
	t1 := self privateOMetaApply: #anything.
	t2 := self privateOMetaApply: #anything.
	t3 := self privateOMetaApply: #anything.
	self pvtOMetaPred: t1 <= t3 & (t3 <= t2).
	^ t3! !

!OMeta2 methodsFor: 'private-ometa2preload'!
space
	| t1 |
	t1 := self privateOMetaApply: #char.
	self pvtOMetaPred: t1 asciiValue <= 32.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
spaces
	^ self
		pvtOMetaMany: [self privateOMetaApply: #space]! !

!OMeta2 methodsFor: 'private-ometa2preload'!
string
	| t1 |
	t1 := self privateOMetaApply: #anything.
	self pvtOMetaPred: t1 isString.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
symbol
	| t1 |
	t1 := self privateOMetaApply: #anything.
	self pvtOMetaPred: t1 isSymbol.
	^ t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
token
	| t1 |
	t1 := self privateOMetaApply: #anything.
	self privateOMetaApply: #spaces.
	^ self privateOMetaApply: #seq withArgument: t1! !

!OMeta2 methodsFor: 'private-ometa2preload'!
upper
	| t1 |
	t1 := self privateOMetaApply: #char.
	self pvtOMetaPred: t1 isUppercase.
	^ t1! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
application
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| as grm rule |
	^ self pvtOMetaOr:
		{
			[
			self
				privateOMetaApply: #token
				withArgument: '^'.
			rule _ self privateOMetaApply: #name.
			as _ self privateOMetaApply: #args.
			{#SuperApp. rule} , as ]. 
			[
			grm _ self privateOMetaApply: #name.
			self
				privateOMetaApply: #exactly
				withArgument: $..
			rule _ self privateOMetaApply: #nsName.
			as _ self privateOMetaApply: #args.
			{#App. #pvtOMetaForeignParser. grm. ('#' , rule) asSymbol} , as ]. 
			[
			rule _ self privateOMetaApply: #name.
			as _ self privateOMetaApply: #args.
			{#App. rule} , as ]
		}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
args
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| ans |
	^ self pvtOMetaOr:
		{
			[
			self
				privateOMetaApply: #exactly
				withArgument: $(.
			ans := self
				privateOMetaApply: #listOf
				withArgs:
					{#squeakArgExprOrWrappedInnerBlock. ','}.
			self
				privateOMetaApply: #token
				withArgument: ')'.
			ans ]. 
			[
			self
				privateOMetaApply: #exactly
				withArgument: $(.
			ans := self
				privateOMetaApply: #listOf
				withArgs:
					{#squeakExpression. '.'}.
			self
				privateOMetaApply: #token
				withArgument: ')'.
			true ifTrue: [
			    "FIXME - uncomment to show warnings while loading...
				Transcript show: 'legacy listOf syntax with args: ' , ans asString; finishEntry."
				ans ]]. 
			[
			self pvtOMetaNot: [
				self
					privateOMetaApply: #exactly
					withArgument: $( ].
			#() ]
		}.! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
characterLiteral
	| t1 |
	self privateOMetaApply: #spaces.
	self privateOMetaApply: #exactly withArgument: $$.
	t1 := self privateOMetaApply: #char.
	^ {#App. #exactly. t1 storeString}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
characters
	| t1 |
	self privateOMetaApply: #token withArgument: '``'.
	t1 := self
				pvtOMetaMany: [self
						pvtOMetaNot: [self privateOMetaApply: #exactly withArgument: $'.
							self privateOMetaApply: #exactly withArgument: $'].
					self privateOMetaApply: #char].
	self privateOMetaApply: #exactly withArgument: $'.
	self privateOMetaApply: #exactly withArgument: $'.
	^ {#App. #seq. (String withAll: t1) storeString}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
expr
	| t1 |
	t1 := self privateOMetaApply: #listOf withArgs: {#expr4. '|'}.
	^ (OrderedCollection with: #Or) addAll: t1;
		 yourself! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
expr1
	| t1 t2 |
	^ self pvtOMetaOr: {[t1 := self pvtOMetaOr: {[self privateOMetaApply: #keyword withArgument: 'true']. [self privateOMetaApply: #keyword withArgument: 'false']. [self privateOMetaApply: #keyword withArgument: 'nil']}.
		{#App. #exactly. t1}]. [self privateOMetaApply: #application]. [self privateOMetaApply: #semanticAction]. [self privateOMetaApply: #semanticPredicate]. [self privateOMetaApply: #characters]. [self privateOMetaApply: #tokenSugar]. [self privateOMetaApply: #stringLiteral]. [self privateOMetaApply: #symbolLiteral]. [self privateOMetaApply: #numberLiteral]. [self privateOMetaApply: #characterLiteral]. [self privateOMetaApply: #token withArgument: '{'.
		t2 := self privateOMetaApply: #expr.
		self privateOMetaApply: #token withArgument: '}'.
		{#Form. t2}]. [self privateOMetaApply: #token withArgument: '<'.
		t2 := self privateOMetaApply: #expr.
		self privateOMetaApply: #token withArgument: '>'.
		{#ConsBy. t2}]. [self privateOMetaApply: #token withArgument: '@<'.
		t2 := self privateOMetaApply: #expr.
		self privateOMetaApply: #token withArgument: '>'.
		{#IdxConsBy. t2}]. [self privateOMetaApply: #token withArgument: '('.
		t2 := self privateOMetaApply: #expr.
		self privateOMetaApply: #token withArgument: ')'.
		t2]}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
expr2
	| t1 |
	^ self pvtOMetaOr: {[self privateOMetaApply: #token withArgument: '~'.
		t1 := self privateOMetaApply: #expr2.
		{#Not. t1}]. [self privateOMetaApply: #token withArgument: '&'.
		t1 := self privateOMetaApply: #expr2.
		{#Lookahead. t1}]. [self privateOMetaApply: #expr1]}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
expr3
	| t1 t2 |
	^ self pvtOMetaOr: {[t1 := self privateOMetaApply: #expr2.
		t1 := self privateOMetaApply: #optIter withArgument: t1.
		self pvtOMetaOr: {[self privateOMetaApply: #exactly withArgument: $:.
			t2 := self privateOMetaApply: #nsName.
			temps add: t2.
			{#Set. t2. t1}]. [t1]}]. [self privateOMetaApply: #token withArgument: ':'.
		t2 := self privateOMetaApply: #nsName.
		temps add: t2.
		{#Set. t2. {#App. #anything}}]}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
expr4
	| t1 |
	t1 := self
				pvtOMetaMany: [self privateOMetaApply: #expr3].
	^ (OrderedCollection with: #And) addAll: t1;
		 yourself! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
initialize
	super initialize.
	temps := IdentitySet new! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
keyword
	| t1 |
	t1 := self privateOMetaApply: #anything.
	self privateOMetaApply: #token withArgument: t1.
	self
		pvtOMetaNot: [self privateOMetaApply: #letterOrDigit].
	^ t1! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
name
	self privateOMetaApply: #spaces.
	^ self privateOMetaApply: #nsName! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
nameFirst
	^ self privateOMetaApply: #letter! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
nameRest
	^ self pvtOMetaOr: {[self privateOMetaApply: #nameFirst]. [self privateOMetaApply: #digit]}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
nsName
	| t1 |
	^ self pvtOMetaOr: {[t1 := self privateOMetaApply: #firstAndRest withArgs: {#nameFirst. #nameRest}.
		(String withAll: t1) asSymbol]. [self privateOMetaApply: #exactly withArgument: $_.
		^ #anything]}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
numberLiteral
	| t1 t2 |
	self privateOMetaApply: #spaces.
	t1 := self pvtOMetaOr: {[self privateOMetaApply: #exactly withArgument: $-.
				self privateOMetaApply: #spaces.
				-1]. [1]}.
	t2 := self
				pvtOMetaMany1: [self privateOMetaApply: #digit].
	^ {#App. #exactly. (t1 * (String withAll: t2) asNumber) storeString}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
optIter
	| t1 |
	t1 := self privateOMetaApply: #anything.
	^ self pvtOMetaOr: {[self privateOMetaApply: #token withArgument: '*'.
		{#Many. t1}]. [self privateOMetaApply: #token withArgument: '+'.
		{#Many1. t1}]. [self privateOMetaApply: #token withArgument: '?'.
		self
			pvtOMetaNot: [self privateOMetaApply: #exactly withArgument: $[].
		{#Opt. t1}]. [t1]}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
ometaRule
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| n x xs |
	^ true ifTrue: [
		n := self pvtOMetaLookahead: [
			self pvtOMetaMany: [
				self
					pvtOMetaSuper: OMeta2
					apply: #space
					withArgs: #() ].
			self privateOMetaApply: #nsName ].
		x := self
			privateOMetaApply: #rulePart
			withArgument: n.
		xs := self pvtOMetaMany: [
			self
				privateOMetaApply: #token
				withArgument: ','.
			self
				privateOMetaApply: #rulePart
				withArgument: n ].
		self privateOMetaApply: #spaces.
		self privateOMetaApply: #end.
		{
			#Rule. 
			n. 
			temps asSortedCollection. 
			(OrderedCollection
				with: #Or
				with: x)
				addAll: xs;
				yourself
		} ]! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
squeakRule
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| squeakCode |
	^ true ifTrue: [
		self pvtOMetaNot: [
			self pvtOMetaMany: [
				self
					pvtOMetaSuper: OMeta2
					apply: #space
					withArgs: #() ].
			self privateOMetaApply: #nsName.
			self privateOMetaApply: #expr4.
			self
				privateOMetaApply: #token
				withArgument: '=' ].
		squeakCode _ self pvtOMetaConsumedBy: [ self pvtOMetaMany: [ self privateOMetaApply: #char ]].
		{#Squeak. squeakCode} ]! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
rule
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ self pvtOMetaOr:
		{[ self privateOMetaApply: #squeakRule ]. [ self privateOMetaApply: #ometaRule ]}.! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
rulePart
	| t1 t2 t3 |
	t1 := self privateOMetaApply: #anything.
	self pvtOMetaPred: (self privateOMetaApply: #name)
			= t1.
	t2 := self privateOMetaApply: #expr4.
	^ self pvtOMetaOr: {[self privateOMetaApply: #token withArgument: '='.
		t3 := self privateOMetaApply: #expr.
		{#And. t2. t3}]. [t2]}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
ruleProduction
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self
			privateOMetaApply: #token
			withArgument: '->' ]! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
semanticAction
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| blk expr |
	^ true ifTrue: [
		self pvtOMetaOpt: [ self privateOMetaApply: #ruleProduction ].
		self
			privateOMetaApply: #token
			withArgument: '['.
		self pvtOMetaOr:
			{[ expr := self privateOMetaApply: #squeakExpression ]. [ blk := self privateOMetaApply: #squeakInnerBlock ]}.
		self
			privateOMetaApply: #exactly
			withArgument: $].
		expr
			ifNil: [
				Array
					with: #SemBlkAct
					with: blk ]
			ifNotNil: [
				Array
					with: #SemAct
					with: expr ]]! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
semanticPredicate
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| blk expr |
	^ true ifTrue: [
		self
			privateOMetaApply: #token
			withArgument: '?['.
		self pvtOMetaOr:
			{[ expr := self privateOMetaApply: #squeakExpression ]. [ blk := self privateOMetaApply: #squeakInnerBlock ]}.
		self
			privateOMetaApply: #exactly
			withArgument: $].
		expr
			ifNil: [
				Array
					with: #SemBlkPred
					with: blk ]
			ifNotNil: [
				Array
					with: #SemPred
					with: expr ]]! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
space
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ self pvtOMetaOr:
		{
			[
			self
				pvtOMetaSuper: OMeta2
				apply: #space
				withArgs: #() ]. 
			[
			self
				privateOMetaApply: #fromTo
				withArgs:
					{'/*'. '*/'} ]. 
			[
			self
				privateOMetaApply: #fromToEndOfLine
				withArgument: '//' ]
		}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
squeakArgExprOrWrappedInnerBlock
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| ans recog |
	^ true ifTrue: [
		recog _ self pvtOMetaGetExternalSmalltalkRecognizerClass.
		ans _ self
			privateOMetaApply: #pvtOMetaForeignParser
			withArgs:
				{recog. #squeakArgExprOrWrappedInnerBlock}.
		self privateOMetaApply: #spaces.
		ans ]! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
squeakExpression
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| ans recog |
	^ true ifTrue: [
		recog := self pvtOMetaGetExternalSmalltalkRecognizerClass.
		ans := self
			privateOMetaApply: #pvtOMetaForeignParser
			withArgs:
				{recog. #squeakExpr}.
		self privateOMetaApply: #spaces.
		ans ]! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
squeakInnerBlock
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| ans recog |
	^ true ifTrue: [
		recog := self pvtOMetaGetExternalSmalltalkRecognizerClass.
		ans := self
			privateOMetaApply: #pvtOMetaForeignParser
			withArgs:
				{recog. #squeakInnerBlock}.
		self privateOMetaApply: #spaces.
		ans ]! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
stringLiteral
	| t1 |
	self privateOMetaApply: #token withArgument: ''''.
	t1 := self
				pvtOMetaMany: [self pvtOMetaOr: {[self privateOMetaApply: #exactly withArgument: $'.
						self privateOMetaApply: #exactly withArgument: $'.
						$']. [self
							pvtOMetaNot: [self privateOMetaApply: #exactly withArgument: $'].
						self privateOMetaApply: #char]}].
	self privateOMetaApply: #exactly withArgument: $'.
	^ {#App. #exactly. (String withAll: t1) storeString}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
symbolLiteral
	| t1 |
	self privateOMetaApply: #token withArgument: '#'.
	t1 := self privateOMetaApply: #nsName.
	^ {#App. #exactly. t1 storeString}! !

!OMeta2RuleParser methodsFor: 'private-ometa2preload'!
tokenSugar
	| t1 |
	self privateOMetaApply: #token withArgument: '"'.
	t1 := self
				pvtOMetaMany: [self
						pvtOMetaNot: [self privateOMetaApply: #exactly withArgument: $"].
					self privateOMetaApply: #char].
	self privateOMetaApply: #exactly withArgument: $".
	^ {#App. #token. (String withAll: t1) storeString}! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

OMeta2RuleParser class
	instanceVariableNames: ''!

!OMeta2RuleParser class methodsFor: 'private-ometa2preload'!
isOMeta2Rule: t1 
	^ [(self matchAll: t1 with: #rule) first ~= #Squeak]
		on: OM2Fail
		do: [false]! !


!OMeta2Optimizer class methodsFor: 'private-ometa2preload'!
optimizeOMetaAst: ast
	^ self
		match:
			(self
				match: ast
				with: #optimizeRule)
		with: #finalOptimizeRule.! !


!OMeta2Optimizer methodsFor: 'private-ometa2preload'!
optimizeRule
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| ans |
	^ true ifTrue: [
		ans := self privateOMetaApply: #anything.
		self pvtOMetaMany: [
			ans := self
				privateOMetaApply: #pvtOMetaForeignParser
				withArgs:
					{OMeta2AndOrOptimizer. #optimize. ans} ].
		ans ]! !


!OMeta2Optimizer methodsFor: 'private-ometa2preload'!
finalOptimizeRule
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| ans |
	^ true ifTrue: [
		ans _ self privateOMetaApply: #anything.
		self pvtOMetaMany: [
			ans _ self
				privateOMetaApply: #pvtOMetaForeignParser
				withArgs:
					{OMeta2FinalizeOptimizer. #optimize. ans} ].
		ans ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
arrayConstr
	^ self pvtOMetaOr: {[true
			ifTrue: [self privateOMetaApply: #token withArgument: '{'.
				self privateOMetaApply: #expr.
				self
					pvtOMetaMany: [true
							ifTrue: [self privateOMetaApply: #token withArgument: '.'.
								self privateOMetaApply: #expr]].
				self pvtOMetaOr: {[self privateOMetaApply: #token withArgument: '.']. [self privateOMetaApply: #empty]}.
				self privateOMetaApply: #token withArgument: '}']]. [true
			ifTrue: [self privateOMetaApply: #token withArgument: '{'.
				self privateOMetaApply: #token withArgument: '}']]}! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
arrayLit
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self
			privateOMetaApply: #token
			withArgument: '#'.
		self
			privateOMetaApply: #token
			withArgument: '('.
		self pvtOMetaMany: [
			self pvtOMetaOr:
				{
					[ self privateOMetaApply: #literal ]. 
					[ self privateOMetaApply: #arrayLit ]. 
					[ self privateOMetaApply: #arraySubLit ]. 
					[
					self privateOMetaApply: #commentAndSpaces.
					self privateOMetaApply: #tsArraySymbol ]
				} ].
		self
			privateOMetaApply: #token
			withArgument: ')' ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
arraySubLit
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self
			privateOMetaApply: #token
			withArgument: '('.
		self pvtOMetaMany: [
			self pvtOMetaOr:
				{
					[ self privateOMetaApply: #literal ]. 
					[ self privateOMetaApply: #arrayLit ]. 
					[ self privateOMetaApply: #arraySubLit ]. 
					[
					self privateOMetaApply: #commentAndSpaces.
					self privateOMetaApply: #tsArraySymbol ]
				} ].
		self
			privateOMetaApply: #token
			withArgument: ')' ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
binary
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self privateOMetaApply: #commentAndSpaces.
		self privateOMetaApply: #tsBinary ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
binaryExpr
	^ self pvtOMetaOr: {[true
			ifTrue: [self privateOMetaApply: #binaryExpr.
				self privateOMetaApply: #binaryMsg]]. [self privateOMetaApply: #unaryExpr]}! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
binaryMsg
	^ true
		ifTrue: [self privateOMetaApply: #binary.
			self privateOMetaApply: #unaryExpr]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
block
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self
			privateOMetaApply: #token
			withArgument: '['.
		self pvtOMetaOr:
			{
				[
				self pvtOMetaMany1: [
					self
						privateOMetaApply: #token
						withArgument: ':'.
					self privateOMetaApply: #identifier ].
				self
					privateOMetaApply: #token
					withArgument: '|' ]. 
				[ self privateOMetaApply: #empty ]
			}.
		self pvtOMetaOr:
			{
				[
				self
					privateOMetaApply: #token
					withArgument: '|'.
				self pvtOMetaMany: [ self privateOMetaApply: #identifier ].
				self
					privateOMetaApply: #token
					withArgument: '|' ]. 
				[ self privateOMetaApply: #empty ]
			}.
		self privateOMetaApply: #commentAndSpaces.
		self pvtOMetaOr:
			{
				[
				self privateOMetaApply: #expr.
				self pvtOMetaMany: [
					self
						privateOMetaApply: #token
						withArgument: '.'.
					self privateOMetaApply: #expr ].
				self pvtOMetaOr:
					{
						[
						self
							privateOMetaApply: #token
							withArgument: '.'.
						self
							privateOMetaApply: #token
							withArgument: '^'.
						self privateOMetaApply: #expr ]. 
						[ self privateOMetaApply: #empty ]
					} ]. 
				[
				self
					privateOMetaApply: #token
					withArgument: '^'.
				self privateOMetaApply: #expr ]. 
				[ self privateOMetaApply: #empty ]
			}.
		self privateOMetaApply: #commentAndSpaces.
		self pvtOMetaOr:
			{
				[
				self
					privateOMetaApply: #token
					withArgument: '.' ]. 
				[ self privateOMetaApply: #empty ]
			}.
		self privateOMetaApply: #commentAndSpaces.
		self
			privateOMetaApply: #token
			withArgument: ']' ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
cascade
	^ self pvtOMetaOr: {[self privateOMetaApply: #identifier]. [self privateOMetaApply: #binaryMsg]. [self privateOMetaApply: #keywordMsg]}! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
comment
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self
			privateOMetaApply: #exactly
			withArgument: $".
		self pvtOMetaConsumedBy: [
			self pvtOMetaMany: [
				self pvtOMetaNot: [
					self
						privateOMetaApply: #exactly
						withArgument: $" ].
				self privateOMetaApply: #anything ]].
		self
			privateOMetaApply: #exactly
			withArgument: $".
		self pvtOMetaOpt: [
			self
				privateOMetaApply: #exactly
				withArgument: $. ]]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
commentAndSpaces
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self pvtOMetaOr:
			{
				[
				self pvtOMetaMany1: [
					self privateOMetaApply: #spaces.
					self privateOMetaApply: #comment ]]. 
				[
				self privateOMetaApply: #spaces.
				self pvtOMetaOpt: [ self privateOMetaApply: #comment ]]
			}.
		self privateOMetaApply: #spaces ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
expr
	^ self pvtOMetaOr: {[true
			ifTrue: [self privateOMetaApply: #identifier.
				self pvtOMetaOr: {[self privateOMetaApply: #token withArgument: ':=']. [self privateOMetaApply: #token withArgument: '_']}.
				self privateOMetaApply: #expr]]. [self privateOMetaApply: #msgExpr]}! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
identifier
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self privateOMetaApply: #commentAndSpaces.
		self privateOMetaApply: #tsIdentifier.
		self pvtOMetaNot: [
			self
				privateOMetaApply: #exactly
				withArgument: $: ]]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
initialize
	super initialize.
	useArgTypeTable := false! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
keyword
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self privateOMetaApply: #commentAndSpaces.
		self privateOMetaApply: #tsKeyword ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
keywordExpr
	^ true
		ifTrue: [self privateOMetaApply: #binaryExpr.
			self privateOMetaApply: #keywordMsg]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
keywordMsg
	^ self pvtOMetaOr: {[true
			ifTrue: [self privateOMetaApply: #keywordMsg.
				self privateOMetaApply: #keywordMsgPart]]. [self privateOMetaApply: #keywordMsgPart]}! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
keywordMsgPart
	^ true
		ifTrue: [self privateOMetaApply: #keyword.
			self privateOMetaApply: #binaryExpr]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
literal
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self privateOMetaApply: #commentAndSpaces.
		self pvtOMetaOr:
			{[ self privateOMetaApply: #tsNumber ]. [ self privateOMetaApply: #tsCharacter ]. [ self privateOMetaApply: #tsString ]. [ self privateOMetaApply: #tsSymbol ]} ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
msgExpr
	^ true
		ifTrue: [self pvtOMetaOr: {[self privateOMetaApply: #keywordExpr]. [self privateOMetaApply: #binaryExpr]}.
			self
				pvtOMetaMany: [true
						ifTrue: [self privateOMetaApply: #token withArgument: ';'.
							self privateOMetaApply: #cascade]]]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
pvtGetTypeTable
	^ useArgTypeTable
		ifTrue: [ ArgTypeTable ]
		ifFalse: [ TypeTable ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
squeakExpr
	^ self
		pvtOMetaConsumedBy: [self privateOMetaApply: #expr]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
squeakInnerBlock
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| innerBlock |
	^ true ifTrue: [
		innerBlock := self pvtOMetaConsumedBy: [
			self pvtOMetaOr:
				{
					[
					self pvtOMetaMany1: [
						self
							privateOMetaApply: #token
							withArgument: ':'.
						self privateOMetaApply: #identifier ].
					self
						privateOMetaApply: #token
						withArgument: '|' ]. 
					[ self privateOMetaApply: #empty ]
				}.
			self pvtOMetaOr:
				{
					[
					self
						privateOMetaApply: #token
						withArgument: '|'.
					self pvtOMetaMany: [ self privateOMetaApply: #identifier ].
					self
						privateOMetaApply: #token
						withArgument: '|' ]. 
					[ self privateOMetaApply: #empty ]
				}.
			self pvtOMetaOr:
				{
					[
					self privateOMetaApply: #expr.
					self pvtOMetaMany: [
						self
							privateOMetaApply: #token
							withArgument: '.'.
						self privateOMetaApply: #expr ].
					self pvtOMetaOr:
						{
							[
							self
								privateOMetaApply: #token
								withArgument: '.'.
							self
								privateOMetaApply: #token
								withArgument: '^'.
							self privateOMetaApply: #expr ]. 
							[ self privateOMetaApply: #empty ]
						} ]. 
					[
					self
						privateOMetaApply: #token
						withArgument: '^'.
					self privateOMetaApply: #expr ]. 
					[ self privateOMetaApply: #empty ]
				}.
			self pvtOMetaOr:
				{
					[
					self
						privateOMetaApply: #token
						withArgument: '.' ]. 
					[ self privateOMetaApply: #empty ]
				} ].
		innerBlock ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
squeakArgExprOrWrappedInnerBlock
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| expr inner |
	^ self pvtOMetaOr:
		{
			[
			self
				privateOMetaApply: #token
				withArgument: '['.
			inner _ self privateOMetaApply: #squeakInnerBlock.
			self
				privateOMetaApply: #token
				withArgument: ']'.
			'(true ifTrue: [' , inner , '])' ]. 
			[
			useArgTypeTable _ true.
			expr _ self privateOMetaApply: #squeakExpr.
			expr ]
		}! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
symbol
	^ true
		ifTrue: [self privateOMetaApply: #token withArgument: '#'.
			self privateOMetaApply: #spaces.
			self pvtOMetaOr: {[self privateOMetaApply: #tsString]. [true
					ifTrue: [self privateOMetaApply: #tsKeyword.
						self pvtOMetaOr: {[self privateOMetaApply: #tsIdentifier]. [self privateOMetaApply: #empty]}]]}]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tcBinaryChar
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| x |
	^ true ifTrue: [
		x := self privateOMetaApply: #char.
		self pvtOMetaPred: (self pvtGetTypeTable at: x asciiValue) == #xBinary ]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsArraySymbol
	^ self pvtOMetaOr: {[true
			ifTrue: [self
					pvtOMetaMany1: [self privateOMetaApply: #tsKeyword].
				self pvtOMetaOr: {[self privateOMetaApply: #tsIdentifier]. [self privateOMetaApply: #empty]}]]. [self privateOMetaApply: #tsIdentifier]}! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsBinary
	^ true
		ifTrue: [self pvtOMetaOr: {[self privateOMetaApply: #exactly withArgument: $|]. [self privateOMetaApply: #tcBinaryChar]}.
			self
				pvtOMetaMany: [self privateOMetaApply: #tcBinaryChar]]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsCharacter
	^ true
		ifTrue: [self privateOMetaApply: #exactly withArgument: $$.
			self privateOMetaApply: #char]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsIdentifier
	^ true
		ifTrue: [self privateOMetaApply: #letter.
			self
				pvtOMetaMany: [self pvtOMetaOr: {[self privateOMetaApply: #letter]. [self privateOMetaApply: #digit]}]]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsKeyword
	^ true
		ifTrue: [self privateOMetaApply: #tsIdentifier.
			self privateOMetaApply: #exactly withArgument: $:]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsNatural
	^ self
		pvtOMetaMany1: [self privateOMetaApply: #digit]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsNumber
	^ true
		ifTrue: [self pvtOMetaOr: {[self privateOMetaApply: #exactly withArgument: $+]. [self privateOMetaApply: #exactly withArgument: $-]. [self privateOMetaApply: #empty]}.
			self privateOMetaApply: #tsNatural]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsString
	^ true
		ifTrue: [self privateOMetaApply: #exactly withArgument: $'.
			self
				pvtOMetaMany: [self pvtOMetaOr: {[true
							ifTrue: [self privateOMetaApply: #exactly withArgument: $'.
								self privateOMetaApply: #exactly withArgument: $']]. [true
							ifTrue: [self
									pvtOMetaNot: [self privateOMetaApply: #exactly withArgument: $'].
								self privateOMetaApply: #char]]}].
			self privateOMetaApply: #exactly withArgument: $']! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsSymbol
	^ true
		ifTrue: [self privateOMetaApply: #exactly withArgument: $#.
			self privateOMetaApply: #spaces.
			self pvtOMetaOr: {[self privateOMetaApply: #tsString]. [self privateOMetaApply: #tsArraySymbol]}]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
unaryExpr
	^ true
		ifTrue: [self privateOMetaApply: #unit.
			self
				pvtOMetaMany: [self privateOMetaApply: #identifier]]! !

!OMeta2SqueakSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
unit
	^ self pvtOMetaOr: {[self privateOMetaApply: #literal]. [self privateOMetaApply: #identifier]. [self privateOMetaApply: #arrayLit]. [self privateOMetaApply: #arrayConstr]. [self privateOMetaApply: #block]. [true
			ifTrue: [self privateOMetaApply: #token withArgument: '('.
				self privateOMetaApply: #expr.
				self privateOMetaApply: #token withArgument: ')']]}! !

"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!

OMeta2SqueakSmalltalkRecognizer class
	instanceVariableNames: ''!

!OMeta2SqueakSmalltalkRecognizer class methodsFor: 'private-ometa2preload'!
initialize
    TypeTable := #(#xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xDelimiter #xDelimiter #xBinary #xDelimiter #xDelimiter #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #doIt #xBinary #xDelimiter #xBinary #xDoubleQuote #xLitQuote #xDollar #xBinary #xBinary #xSingleQuote #leftParenthesis #rightParenthesis #xBinary #xBinary #xBinary #xBinary #period #xBinary #xDigit #xDigit #xDigit #xDigit #xDigit #xDigit #xDigit #xDigit #xDigit #xDigit #xColon #semicolon #xBinary #xBinary #xBinary #xBinary #xBinary #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #leftBracket #xBinary #rightBracket #upArrow #leftArrow #xBinary #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #leftBrace #verticalBar #rightBrace #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xLetter #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xBinary #xLetter #xBinary #xBinary #xBinary #xBinary #xLetter #xBinary #xBinary #xBinary #xBinary #xBinary #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xBinary #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xBinary #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xLetter #xBinary ).
	ArgTypeTable := TypeTable copy.
	ArgTypeTable
		at: 44
		put: #xLetter! !


OMeta2SqueakSmalltalkRecognizer initialize!

!OMeta2CuisSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
backtickExpr
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self
			privateOMetaApply: #exactly
			withArgument: $`.
		self pvtOMetaMany: [
			self pvtOMetaNot: [
				self
					privateOMetaApply: #exactly
					withArgument: $` ].
			self privateOMetaApply: #anything ].
		self
			privateOMetaApply: #exactly
			withArgument: $` ]! !

!OMeta2CuisSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
byteArrayLit
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self
			privateOMetaApply: #token
			withArgument: '#'.
		self
			privateOMetaApply: #token
			withArgument: '['.
		self pvtOMetaMany: [
			self pvtOMetaOr:
				{
					[ self privateOMetaApply: #literal ]. 
					[
					self privateOMetaApply: #commentAndSpaces.
					self privateOMetaApply: #tsArraySymbol ]
				} ].
		self
			privateOMetaApply: #token
			withArgument: ']' ]! !

!OMeta2CuisSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
identifier
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ self pvtOMetaOr:
		{
			[
			self privateOMetaApply: #commentAndSpaces.
			self privateOMetaApply: #backtickExpr ]. 
			[
			self
				pvtOMetaSuper: OMeta2SqueakSmalltalkRecognizer
				apply: #identifier
				withArgs:
					{} ]
		}! !

!OMeta2CuisSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
msgExpr
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self pvtOMetaOr:
			{[ self privateOMetaApply: #keywordExpr ]. [ self privateOMetaApply: #binaryExpr ]}.
		self pvtOMetaMany: [
			self
				privateOMetaApply: #token
				withArgument: ';'.
			self privateOMetaApply: #cascade ].
		self pvtOMetaMany: [
			self
				privateOMetaApply: #token
				withArgument: '::'.
			self privateOMetaApply: #cascade ]]! !

!OMeta2CuisSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
tsSymbolIdentifier
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ true ifTrue: [
		self pvtOMetaConsumedBy: [
			self pvtOMetaOr:
				{
					[ self privateOMetaApply: #letter ]. 
					[
					self
						privateOMetaApply: #exactly
						withArgument: $_ ]
				}.
			self pvtOMetaMany: [
				self pvtOMetaOr:
					{
						[ self privateOMetaApply: #letter ]. 
						[ self privateOMetaApply: #digit ]. 
						[
						self
							privateOMetaApply: #exactly
							withArgument: $_ ]. 
						[
						self
							privateOMetaApply: #exactly
							withArgument: $: ]
					} ]]]! !

!OMeta2CuisSmalltalkRecognizer methodsFor: 'private-ometa2preload'!
unit
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	^ self pvtOMetaOr:
		{
			[ self privateOMetaApply: #byteArrayLit ]. 
			[ self privateOMetaApply: #backtickExpr ]. 
			[
			self
				pvtOMetaSuper: OMeta2SqueakSmalltalkRecognizer
				apply: #unit
				withArgs:
					{} ]
		}! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
and
	| t1 |
	^ true
		ifTrue: [t1 := self
						pvtOMetaMany: [self privateOMetaApply: #trans].
			t1 addFirst: #And;
				 yourself]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
consby
	| t1 |
	^ true
		ifTrue: [t1 := self privateOMetaApply: #trans.
			{#ConsBy. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
form
	| t1 |
	^ true
		ifTrue: [t1 := self privateOMetaApply: #trans.
			{#Form. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
helped
	^ self pvtOMetaPred: didSomething! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
idxconsby
	| t1 |
	^ true
		ifTrue: [t1 := self privateOMetaApply: #trans.
			{#IdxConsBy. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
initialize
	super initialize.
	didSomething := false! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
lookahead
	| t1 |
	^ true
		ifTrue: [t1 := self privateOMetaApply: #trans.
			{#Lookahead. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
many
	| t1 |
	^ true
		ifTrue: [t1 := self privateOMetaApply: #trans.
			{#Many. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
many1
	| t1 |
	^ true
		ifTrue: [t1 := self privateOMetaApply: #trans.
			{#Many1. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
not
	| t1 |
	^ true
		ifTrue: [t1 := self privateOMetaApply: #trans.
			{#Not. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
opt
	| t1 |
	^ true
		ifTrue: [t1 := self privateOMetaApply: #trans.
			{#Opt. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
optimize
	| t1 |
	^ true
		ifTrue: [t1 := self privateOMetaApply: #trans.
			self privateOMetaApply: #helped.
			t1]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
or
	| t1 |
	^ true
		ifTrue: [t1 := self
						pvtOMetaMany: [self privateOMetaApply: #trans].
			t1 addFirst: #Or;
				 yourself]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
rule
	| t1 t2 t3 |
	^ true
		ifTrue: [t2 := self privateOMetaApply: #anything.
			t3 := self privateOMetaApply: #anything.
			t1 := self privateOMetaApply: #trans.
			{#Rule. t2. t3. t1}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
set
	| t1 t2 |
	^ true
		ifTrue: [t1 := self privateOMetaApply: #anything.
			t2 := self privateOMetaApply: #trans.
			{#Set. t1. t2}]! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
setHelped
	^ didSomething := true! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
trans
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| ans t |
	^ self pvtOMetaOr:
		{
			[
			self pvtOMetaForm: [
				t := self privateOMetaApply: #anything.
				t := t asLowercase asSymbol.
				self pvtOMetaPred: (self class canUnderstand: t).
				ans := self
					privateOMetaApply: #applyRule
					withArgument: t ].
			ans ]. 
			[ self privateOMetaApply: #anything ]
		}! !

!OMeta2NullOptimizer methodsFor: 'private-ometa2preload'!
trueiftrue
	| t1 |
	^ true
		ifTrue: [t1 := self privateOMetaApply: #trans.
			{#TrueIfTrue. t1}]! !

!OMeta2AndOrOptimizer methodsFor: 'private-ometa2preload'!
and
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| x xs |
	^ self pvtOMetaOr:
		{
			[
			x _ self privateOMetaApply: #trans.
			self privateOMetaApply: #end.
			self privateOMetaApply: #setHelped.
			x ]. 
			[
			xs _ self
				privateOMetaApply: #transInside
				withArgument: #And.
			xs
				addFirst: #And;
				yourself ]
		}! !

!OMeta2AndOrOptimizer methodsFor: 'private-ometa2preload'!
or
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| x xs |
	^ self pvtOMetaOr:
		{
			[
			x := self privateOMetaApply: #trans.
			self privateOMetaApply: #end.
			self privateOMetaApply: #setHelped.
			x ]. 
			[
			xs := self
				privateOMetaApply: #transInside
				withArgument: #Or.
			xs
				addFirst: #Or;
				yourself ]
		}! !

!OMeta2AndOrOptimizer methodsFor: 'private-ometa2preload'!
transInside
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| t x xs ys |
	^ true ifTrue: [
		t := self privateOMetaApply: #anything.
		self pvtOMetaOr:
			{
				[
				self pvtOMetaForm: [
					self
						privateOMetaApply: #exactly
						withArgument: t.
					xs := self
						privateOMetaApply: #transInside
						withArgument: t ].
				ys := self
					privateOMetaApply: #transInside
					withArgument: t.
				self privateOMetaApply: #setHelped.
				xs , ys ]. 
				[
				x := self privateOMetaApply: #trans.
				xs := self
					privateOMetaApply: #transInside
					withArgument: t.
				xs
					addFirst: x;
					yourself ]. 
				[
				self privateOMetaApply: #empty.
				OrderedCollection new ]
			} ]! !

!OMeta2FinalizeOptimizer methodsFor: 'private-ometa2preload'!
rule
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| body name temps |
	^ true ifTrue: [
		name := self privateOMetaApply: #anything.
		temps := self privateOMetaApply: #anything.
		body := self privateOMetaApply: #trans.
		OrderedCollection new
			add: #Rule;
			add: name;
			add: temps;
			add:
				((#(#Or #TrueIfTrue) includes: body first)
					ifTrue: [
						body ]
					ifFalse: [
						self setHelped.
						{#TrueIfTrue. body} ]);
			yourself ].! !

!OMeta2FinalizeOptimizer methodsFor: 'private-ometa2preload'!
set
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| name val |
	^ true ifTrue: [
		name := self privateOMetaApply: #anything.
		val := self privateOMetaApply: #trans.
		{
			#Set. 
			name. 
			val first = #And
				ifTrue: [
					self setHelped.
					{#TrueIfTrue. val} ]
				ifFalse: [ val ]
		} ].! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
semact
	| t1 |
	t1 := self privateOMetaApply: #string.
	^ {'('. t1. ')'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
semblkact
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| x |
	^ true ifTrue: [
		x := self privateOMetaApply: #string.
		{'true ifTrue:['. x. ']'} ]! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
and
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| xs |
	^ true ifTrue: [
		xs := self pvtOMetaMany: [ self privateOMetaApply: #trans ].
		{
			self
				delim: xs
				with: '. '
		} ]! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
app
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| args rule |
	^ true ifTrue: [
		self
			flag: #privateOMetaApply:;
			flag: #privateOMetaApply:withArgs:.
		rule := self privateOMetaApply: #symbol.
		self pvtOMetaOr:
			{
				[
				args := self pvtOMetaMany1: [ self privateOMetaApply: #anything ].
				args size = 1
					ifTrue: [
						{'(self privateOMetaApply: '. rule storeString. ' withArgument: '. args first. ')'} ]
					ifFalse: [
						{
							'(self privateOMetaApply: '. 
							rule storeString. 
							' withArgs: {'. 
							self
								delim: args
								with: '. '. 
							'})'
						} ]]. 
				[
				{'(self privateOMetaApply: '. rule storeString. ')'} ]
			} ]! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
consby
	| t1 |
	t1 := self privateOMetaApply: #trans.
	^ {'(self pvtOMetaConsumedBy: ['. t1. '])'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
delim: t1 with: t2 
	| t3 t4 |
	t3 := true.
	t4 := OrderedCollection new.
	t1
		do: [:t5 | 
			t3
				ifTrue: [t3 := false]
				ifFalse: [t4 add: t2].
			t4 add: t5].
	^ t4! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
form
	| t1 |
	t1 := self privateOMetaApply: #trans.
	^ {'(self pvtOMetaForm: ['. t1. '])'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
idxconsby
	| t1 |
	t1 := self privateOMetaApply: #trans.
	^ {'(self pvtOMetaIndexConsumedBy: ['. t1. '])'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
lookahead
	| t1 |
	t1 := self privateOMetaApply: #trans.
	^ {'(self pvtOMetaLookahead: ['. t1. '])'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
many
	| t1 |
	t1 := self privateOMetaApply: #trans.
	^ {'(self pvtOMetaMany: ['. t1. '])'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
many1
	| t1 |
	t1 := self privateOMetaApply: #trans.
	^ {'(self pvtOMetaMany1: ['. t1. '])'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
not
	| t1 |
	t1 := self privateOMetaApply: #trans.
	^ {'(self pvtOMetaNot: ['. t1. '])'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
opt
	| t1 |
	t1 := self privateOMetaApply: #trans.
	^ {'(self pvtOMetaOpt: ['. t1. '])'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
or
	| t1 t2 |
	t1 := self
				pvtOMetaMany: [t2 := self privateOMetaApply: #trans.
					{'['. t2. ']'}].
	^ {'(self pvtOMetaOr: {'. self delim: t1 with: '. '. '})'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
sempred
	| t1 |
	t1 := self privateOMetaApply: #string.
	^ {'(self pvtOMetaPred: ('. t1. '))'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
semblkpred
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| x |
	^ true ifTrue: [
		self flag: #pvtOMetaPred:.
		x _ self privateOMetaApply: #string.
		{'(self pvtOMetaPred: (true ifTrue:['. x. ']))'} ]! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
rule
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| body name temps |
	^ true ifTrue: [
		name := self privateOMetaApply: #symbol.
		temps := self privateOMetaApply: #anything.
		temps := temps select: [ :t |
			(grammarClass instVarNames includes: t) not ].
		body := self privateOMetaApply: #trans.
		{
			name. 
			self class constOMetaGeneratorString. 
			' |'. 
			self
				delim: temps asSortedCollection
				with: ' '. 
			' | ^ true ifTrue: ['. 
			body. 
			']'
		} ]! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
set
	| t1 t2 |
	t1 := self privateOMetaApply: #symbol.
	t2 := self privateOMetaApply: #trans.
	^ {'('. t1 asString. ' := '. t2. ')'}! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
squeak
	^ self privateOMetaApply: #string! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
superapp
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| args rule |
	^ true ifTrue: [
		self flag: #pvtOMetaSuper:apply:withArgs:.
		rule := self privateOMetaApply: #symbol.
		args := self pvtOMetaMany: [ self privateOMetaApply: #anything ].
		args size = 1
			ifTrue: [
				{'(self pvtOMetaSuper: '. grammarClass superclass name. ' apply: '. rule storeString. ' withArgument: '. args first. ')'} ]
			ifFalse: [
				{
					'(self pvtOMetaSuper: '. 
					grammarClass superclass name. 
					' apply: '. 
					rule storeString. 
					' withArgs: {'. 
					self
						delim: args
						with: '. '. 
					'})'
				} ]]! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
trans
	| t1 t2 |
	self
		pvtOMetaForm: [t1 := self privateOMetaApply: #symbol.
			t2 := self privateOMetaApply: t1 asLowercase asSymbol].
	^ t2! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
translate
	grammarClass := self privateOMetaApply: #anything.
	^ self privateOMetaApply: #trans! !

!OMeta2RuleTranslator methodsFor: 'private-ometa2preload'!
trueiftrue
	"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"
	| xs |
	^ true ifTrue: [
		xs := self pvtOMetaMany: [ self privateOMetaApply: #trans ].
		{'(true ifTrue: ['. xs. '])'} ]! !

!OMeta2RuleTranslator class methodsFor: 'constants' stamp: 'pb 5/23/2018 03:01:33'!
constOMetaGeneratorString
	"Not called yet but needs to exist for OMeta2.pck.st"
        ^ '"Generated by OMeta... edit the rule (i.e. show...->source), not this Smalltalk code"'.! !

!OMeta2Flattener methodsFor: 'private-ometa2preload'!
flatten
	| t1 |
	t1 := self privateOMetaApply: #anything.
	self privateOMetaApply: #iFlatten withArgument: t1.
	^ ws contents! !

!OMeta2Flattener methodsFor: 'private-ometa2preload'!
iFlatten
	| t1 |
	^ self pvtOMetaOr: {[t1 := self privateOMetaApply: #string.
		ws nextPutAll: t1]. [self
			pvtOMetaForm: [self
				pvtOMetaMany: [self privateOMetaApply: #iFlatten]]]}! !

!OMeta2Flattener methodsFor: 'private-ometa2preload'!
initialize
	super initialize.
	ws := (String new: 64) writeStream! !







!OMeta2Base class methodsFor: 'accessing' stamp: 'aw 2/20/2009 14:52'!
compilerClass
        ^ OMeta2Compiler! !

!OMeta2Base class methodsFor: 'private-ometa2preload' stamp: 'pb 6/08/2015 15:45'!
ometa2RuleParserClass
	^ OMeta2RuleParser! !

!OMeta2Base class methodsFor: 'private-ometa2preload' stamp: 'pb 6/08/2015 15:45'!
ometa2OptimizerClass
	^ OMeta2Optimizer! !

!OMeta2Base class methodsFor: 'private-ometa2preload' stamp: 'pb 6/08/2015 15:45'!
ometa2RuleTranslatorClass
	^ OMeta2RuleTranslator! !

!OMeta2Base class methodsFor: 'private-ometa2preload' stamp: 'pb 6/08/2015 15:45'!
ometa2FlattenerClass
	^ OMeta2Flattener! !


OM2Fail initialize!
OMeta2SqueakSmalltalkRecognizer initialize!

"-- END OF STAGE 1 BOOTSTRAP --"!
